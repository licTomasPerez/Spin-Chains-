# -*- coding: utf-8 -*-
"""Heisenberg Model - Wave packet - Last Build - Qutip.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E8878wqpbZ0baF6ZJyJ5CSrJ8uF0Vu4t

## Heisenberg Model

The Heisenberg Hamiltonian is given by

$${{\hat {H}_H}=-{\frac {1}{2}}\sum _{j=1}^{N}(J_{x}\sigma _{j}^{x}\sigma _{j+1}^{x}+J_{y}\sigma _{j}^{y}\sigma _{j+1}^{y}+J_{z}\sigma _{j}^{z}\sigma _{j+1}^{z}+h\sigma _{j}^{z})}$$

where $J_{a}, a \in {x,y,z}$ are real-valued constants and where the Pauli operators follow the standard $SU(2)$ conmutation algebra: $$[\sigma^a_i, \sigma^b_j]=i \delta_{ij}\epsilon^{abc}\sigma^c$$. 

In particular we are interested in the XYZ Heisenberg model \textit{ie.} $J_x \neq J_y \neq J_z$
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
import numpy as np
from qutip import *

### XYZ Heisenberg model

solver = "me"   
N = 5            # número de spines

h  = 1.0 * 2 * np.pi * np.ones(N) 
Jz = 0.1 * 2 * np.pi * np.ones(N)
Jx = 0.15 * 2 * np.pi * np.ones(N)
Jy = 0.2 * 2 * np.pi * np.ones(N)

def hamiltonian(N, Jx, Jy, Jz, h, psi0, tlist, gamma, solver):
    
    id2 = qeye(2)
    sx = sigmax()
    sy = sigmay()
    sz = sigmaz()
    
    sx_list = []
    sy_list = []
    sz_list = []
    one_half_list = []
    num_expression_sz = []

    for n in range(N):
        operator_list = []
        for m in range(N):
            operator_list.append(id2)
        
        operator_list[n] = sx
        sx_list.append(tensor(operator_list))
        
        operator_list[n] = sy
        sy_list.append(tensor(operator_list))
        
        operator_list[n] = sz
        sz_list.append(tensor(operator_list))

    # Constructing the Hamiltonian
    
    H = 0
    
    for n in range(N):
        H += -0.5*h[n]*sz_list[n]
        
    for n in range(N-1):
        H += -0.5 * Jx[n] * sx_list[n] * sx_list[n+1]
        H += -0.5 * Jy[n] * sy_list[n] * sy_list[n+1]
        H += -0.5 * Jz[n] * sz_list[n] * sz_list[n+1]
    
    # collapse operators
    c_op_list = []

    # spin dephasing
    for n in range(N):
        if gamma[n] > 0.0:
            c_op_list.append(np.sqrt(gamma[n]) * sz_list[n])
    
    if solver == "me":
        result = mesolve(H, psi0, tlist, c_op_list, sz_list)
    elif solver == "mc":
        ntraj = 200 
        result = mcsolve(H, psi0, tlist, c_op_list, sz_list, ntraj)

    return result.expect

# dephasing rate
gamma = 5 * 10**-1 * np.ones(N)

# intial state, first spin in state |1>, the rest in state |0>
psi_list = []
for n in range(2):
    psi_list.append(basis(2,0))
psi_list.append(basis(2,1))
for n in range(2):
    psi_list.append(basis(2,0))
psi0 = tensor(psi_list)

tlist = np.linspace(0, 0.1, 400)

sz_expt = hamiltonian(N, Jx, Jy, Jz, h, psi0, tlist, gamma, solver)

"""Here we are interested in computing the following expression

$$
\mu_X = \frac{\bigg(\sum_{i=1}^N\langle s_z^i \rangle+ \frac{1}{2}\bigg)i}{\sum_{i=1}^N\langle s_z^i \rangle+ \frac{1}{2}}
$$

and the standard deviation is 


$$
\sigma^2_X= \frac{\bigg(\sum_{i=1}^N\langle s_{z}^{i} \rangle+ \frac{1}{2}\bigg)i^2}{\sum_{i=1}^N\langle s_z^i \rangle+ \frac{1}{2}} - \bigg[\frac  {\bigg(\sum_{i=1}^N\langle s_{z}^{i} \rangle+ \frac{1}{2}\bigg)i}{\sum_{i=1}^N\langle s_z^i \rangle+ \frac{1}{2}}\bigg]^2
$$
"""

numerador = [0 for t in range(len(sz_expt[1]))] # Me inicializo esta lista de 0 a 200 segundos para calcular las cosas del numerador
numerador_cuadrado = [0 for t in range(len(sz_expt[1]))]
denominador = [0 for t in range(len(sz_expt[1]))] # ídem pero para el denominador

# Ahora para cada uno de los 200 segundos, hago las sumas de 0 a 5 sitios de la red de los valores de expectación. Básicamente tengo que muX 
# es una función de 0 a 200 segundos, habiendo hecho las sumas sobre los sitios. 
for m in range(len(sz_expt[1])): 
    for n in range(len(sz_expt)):
      numerador += ((sz_expt[n][m]) + 0.5 * np.ones(len(sz_expt[1]))) * (n+1)
      numerador_cuadrado += ((sz_expt[n][m]) + 0.5 * np.ones(len(sz_expt[1]))) * (n+1)**2
      denominador += (sz_expt[n][m]) + 0.5 * np.ones(len(sz_expt[1]))

# muX como función del tiempo 
muX = [numerador[t]/denominador[t] for t in range(len(sz_expt[1]))]    
SDE = [np.sqrt(numerador_cuadrado[t]/denominador[t] - (numerador[t]/denominador[t])**2) for t in range(len(sz_expt[1]))]

fig, ax = plt.subplots(figsize=(10,6))

ax.plot(tlist, muX, label=r'$\mu_X$')
ax.plot(tlist, SDE, label=r'$SDE$')

ax.legend(loc=0)
ax.set_xlabel(r'Time [s]')
ax.set_ylabel(r'$\mu_X$')
ax.set_title(r'$\mu_X  vs. t[s]$');

fig, ax = plt.subplots(figsize=(10,6))

ax.plot(tlist, denominador, label=r'$\sum_{i=1}^N\langle s_z^i \rangle+ \frac{1}{2})(i)$')

ax.legend(loc=0)
ax.set_xlabel(r'Time [s]')
ax.set_ylabel(r'$\sum_{i=1}^N\langle s_z^i \rangle+ \frac{1}{2})(i)$')
ax.set_title(r'$\sum_{i=1}^N\langle s_z^i \rangle+ \frac{1}{2})(i) vs. t[s]$');

from qutip.ipynbtools import version_table
version_table()



def hamiltonian(N, Jx, Jy, Jz, h, psi0, tlist, gamma, solver):
    
    id2 = qeye(2)
    sx = sigmax()
    sy = sigmay()
    sz = sigmaz()
    
    sx_list = []
    sy_list = []
    sz_list = []
    
    for n in range(N):
        operator_list = []
        for m in range(N):
            operator_list.append(id2)
        
        operator_list[n] = sx
        sx_list.append(tensor(operator_list))
        
        operator_list[n] = sy
        sy_list.append(tensor(operator_list))
        
        operator_list[n] = sz
        sz_list.append(tensor(operator_list))
    
    # Constructing the Hamiltonian
    
    H = 0
    
    for n in range(N):
        H += -0.5*h[n]*sz_list[n]
        
    for n in range(N-1):
        H += -0.5 * Jx[n] * sx_list[n] * sx_list[n+1]
        H += -0.5 * Jy[n] * sy_list[n] * sy_list[n+1]
        H += -0.5 * Jz[n] * sz_list[n] * sz_list[n+1]
    
    # collapse operators
    c_op_list = []

    # spin dephasing
    for n in range(N):
        if gamma[n] > 0.0:
            c_op_list.append(np.sqrt(gamma[n]) * sz_list[n])
    
    if solver == "me":
        result = mesolve(H, psi0, tlist, c_op_list, sz_list)
    elif solver == "mc":
        ntraj = 200 
        result = mcsolve(H, psi0, tlist, c_op_list, sz_list, ntraj)

    return result.expect

# dephasing rate
gamma = 5 * 10**-10 * np.ones(N)

# intial state, first spin in state |1>, the rest in state |0>
psi_list = []
psi_list.append(basis(2,1))
for n in range(N-1):
    psi_list.append(basis(2,0))
psi0 = tensor(psi_list)

tlist = np.linspace(0, 20, 200)

sz_expt = hamiltonian(N, Jx, Jy, Jz, h, psi0, tlist, gamma, solver)

sz_expt[1]

fig, ax = plt.subplots(figsize=(10,6))

for n in range(N):
    ax.plot(tlist, np.real(sz_expt[n]), label=r'$\langle\sigma_z^{(%d)}\rangle$'%n)

ax.legend(loc=0)
ax.set_xlabel(r'Time [s]')
ax.set_ylabel(r'$\langle\sigma_z\rangle$')
ax.set_title(r'Dynamics of a Heisenberg spin chain for N=5 spins and $\gamma = 5\times 10^{-10} $');

